Waterfall Model

1. Requirements - Requirement gathering by PM and Designers
2. Design - Design team and senior engineers
3. Development - SDE1, SDE2
4. Testing - SDET
5. Deployment - Devops or Devloper team
6. Maintainance

//////////////////////////////////////////////////

Monolithic and Microservices Architecture

1. Monolithic

+----------------------------------+
|          Monolithic App          |
|----------------------------------|
|  UI                              |
|  Business Logic                  |
|  Authentication                  |
|  Orders                          |
|  Payments                        |
|  Database Access                 |
+----------------------------------+
            |
        One Database


2. Microservices


+-----------+     +-----------+
| User      |     | Order     |
| Service   |     | Service   |
+-----------+     +-----------+
      |                 |
  User DB          Order DB

+-----------+     +-----------+
| Payment   |     | Inventory |
| Service   |     | Service   |
+-----------+     +-----------+
      |                 |
 Payment DB      Inventory DB


üß± Monolithic Architecture

A monolith is a single, unified application where all components run together.

Characteristics

One codebase

One deployment unit

Shared database

All features tightly coupled

Example

A web app where:

UI

Business logic

Authentication

Database access
are all in one application.

‚úÖ Pros

Simple to develop and deploy

Easier debugging and testing (at small scale)

Better performance (no network calls)

Ideal for small teams and MVPs

‚ùå Cons

Hard to scale specific features

Any change requires redeploying the entire app

Large codebases become difficult to maintain

One bug can crash the whole system

üß© Microservices Architecture

Microservices split the application into small, independent services that communicate over APIs.

Characteristics

Multiple small services

Independent deployments

Each service owns its database

Communicate via HTTP/REST, gRPC, or messaging

Example

An e-commerce system with:

User Service

Order Service

Payment Service

Inventory Service
Each deployed separately.

‚úÖ Pros

Independent scaling of services

Faster development with multiple teams

Fault isolation (one service failing won‚Äôt stop others)

Technology flexibility (different languages/frameworks)

‚ùå Cons

Complex to design and manage

Requires DevOps, monitoring, and automation

Network latency and failure handling

Harder debugging and testing